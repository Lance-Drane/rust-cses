// I/O boilerplate //

use std::io::Read;

// problem //

/// A rotation of a string can be generated by moving characters one after another from beginning to end. For example, the rotations of acab are acab, caba, abac, and baca.
///
/// Your task is to determine the lexicographically minimal rotation of a string.
///
/// <b>Input</b>
///
/// The only input line contains a string of length n. Each character is one of a–z.
///
/// <b>Output</b>
///
/// Print the lexicographically minimal rotation.
///
/// <b>Constraints</b>
///
/// <ul>
/// <li>1 ≤ n ≤ 10<sup>6</sup></li>
/// </ul>
fn solve<W: std::io::Write>(scan: &mut Vec<u8>, out: &mut W) {
    scan.pop();
    let len = scan.len();
    scan.extend_from_within(0..); // "double the string" to avoid doing any modular arithmetic
    let len_full = scan.len();

    // Duval's algorithm for Lyndon factorization
    let mut ans = 0;
    let mut ptr_start = 0;
    while ptr_start < len {
        ans = ptr_start;
        let mut ptr_end = ptr_start + 1;
        let mut ptr_curr = ptr_start;
        while ptr_end < len_full {
            unsafe {
                match scan
                    .get_unchecked(ptr_curr)
                    .cmp(scan.get_unchecked(ptr_end))
                {
                    std::cmp::Ordering::Less => {
                        ptr_curr = ptr_start;
                    }
                    std::cmp::Ordering::Equal => {
                        ptr_curr += 1;
                    }
                    std::cmp::Ordering::Greater => break,
                }
                ptr_end += 1;
            }
        }
        while ptr_start <= ptr_curr {
            ptr_start += ptr_end - ptr_curr;
        }
    }

    unsafe {
        out.write_all(scan.get_unchecked(ans..ans + len))
            .unwrap_unchecked();
    }
}

// entrypoints //

fn main() {
    let mut buf_str = vec![];
    std::io::stdin().lock().read_to_end(&mut buf_str).unwrap();
    let mut out = std::io::stdout().lock();
    solve(&mut buf_str, &mut out);
}

#[cfg(test)]
mod test {
    use super::*;

    fn test(input: &[u8], target: &[u8]) {
        let mut out = Vec::with_capacity(target.len());
        solve(&mut input.to_owned(), &mut out);

        assert_eq!(out, target);
    }

    #[test]
    fn test_example() {
        let input = b"\
acab
";
        let target = b"\
abac";

        test(input, target);
    }

    #[test]
    fn test_example_2() {
        let input = b"\
aaabaaa
";
        let target = b"\
aaaaaab";

        test(input, target);
    }

    #[test]
    fn test_example_3() {
        let input = b"\
helloworld
";
        let target = b"\
dhelloworl";

        test(input, target);
    }

    #[test]
    fn test_example_4() {
        let input = b"\
abrakadabraalakazam
";
        let target = b"\
aalakazamabrakadabr";

        test(input, target);
    }
}
